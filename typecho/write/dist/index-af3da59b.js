import { c as countColumn, L as Language, d as defineLanguageFacet, i as indentService, s as syntaxTree, T as Tree, g as getIndentUnit, N as NodeSet, a as NodeType, b as styleTags, l as languageDataProp, t as tags } from './index-8d03edaf.js';

function countCol(t,e,s,n=0,r=0){return null==e&&-1==(e=t.search(/[^\s\u00a0]/))&&(e=t.length),countColumn(t.slice(n,e),r,s)}class StringStream{constructor(t,e,s){this.string=t,this.tabSize=e,this.indentUnit=s,this.pos=0,this.start=0,this.lastColumnPos=0,this.lastColumnValue=0;}eol(){return this.pos>=this.string.length}sol(){return 0==this.pos}peek(){return this.string.charAt(this.pos)||void 0}next(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)}eat(t){let e,s=this.string.charAt(this.pos);if(e="string"==typeof t?s==t:s&&(t instanceof RegExp?t.test(s):t(s)),e)return ++this.pos,s}eatWhile(t){let e=this.pos;for(;this.eat(t););return this.pos>e}eatSpace(){let t=this.pos;for(;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++this.pos;return this.pos>t}skipToEnd(){this.pos=this.string.length;}skipTo(t){let e=this.string.indexOf(t,this.pos);if(e>-1)return this.pos=e,!0}backUp(t){this.pos-=t;}column(){return this.lastColumnPos<this.start&&(this.lastColumnValue=countCol(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue}indentation(){return countCol(this.string,null,this.tabSize)}match(t,e,s){if("string"==typeof t){let n=t=>s?t.toLowerCase():t;return n(this.string.substr(this.pos,t.length))==n(t)?(!1!==e&&(this.pos+=t.length),!0):null}{let s=this.string.slice(this.pos).match(t);return s&&s.index>0?null:(s&&!1!==e&&(this.pos+=s[0].length),s)}}current(){return this.string.slice(this.start,this.pos)}}function fullParser(t){return {token:t.token,blankLine:t.blankLine||(()=>{}),startState:t.startState||(()=>!0),copyState:t.copyState||defaultCopyState,indent:t.indent||(()=>null),languageData:t.languageData||{}}}function defaultCopyState(t){if("object"!=typeof t)return t;let e={};for(let s in t){let n=t[s];e[s]=n instanceof Array?n.slice():n;}return e}class StreamLanguage extends Language{constructor(t){let e=defineLanguageFacet(t.languageData),s=fullParser(t);super(e,{startParse:(t,e,s)=>new Parse(this,t,e,s)},docID(e),[indentService.of(((t,e)=>this.getIndent(t,e)))]),this.streamParser=s,this.stateAfter=new WeakMap;}static define(t){return new StreamLanguage(t)}getIndent(t,e){let s=syntaxTree(t.state),n=s.resolve(e);for(;n&&n.type!=this.topNode;)n=n.parent;if(!n)return null;let r,i,a=findState(this,s,0,n.from,e);if(a?(i=a.state,r=a.pos+1):(i=this.streamParser.startState(t.unit),r=0),e-r>1e4)return null;for(;r<e;){let s=t.state.doc.lineAt(r),n=Math.min(e,s.to);if(s.length){let e=new StringStream(s.text,t.state.tabSize,t.unit);for(;e.pos<n-s.from;)readToken(this.streamParser.token,e,i);}else this.streamParser.blankLine(i,t.unit);if(n==e)break;r=s.to+1;}let{text:o}=t.state.doc.lineAt(e);return this.streamParser.indent(i,/^\s*(.*)/.exec(o)[1],t)}get allowsNesting(){return !1}}function findState(t,e,s,n,r){let i=s>=n&&s+e.length<=r&&t.stateAfter.get(e);if(i)return {state:t.streamParser.copyState(i),pos:s+e.length};for(let i=e.children.length-1;i>=0;i--){let a=e.children[i],o=s+e.positions[i],h=a instanceof Tree&&o<r&&findState(t,a,o,n,r);if(h)return h}return null}function cutTree(t,e,s,n,r){if(r&&s<=0&&n>=e.length)return e;r||e.type!=t.topNode||(r=!0);for(let i=e.children.length-1;i>=0;i--){let a,o=e.positions[i]+s,h=e.children[i];if(o<n&&h instanceof Tree){if(!(a=cutTree(t,h,s-o,n-o,r)))break;return r?new Tree(e.type,e.children.slice(0,i).concat(a),e.positions.slice(0,i+1),o+a.length):a}}return null}function findStartInFragments(t,e,s,n){for(let n of e){let e,r=n.from<=s&&n.to>s&&findState(t,n.tree,0-n.offset,s,n.to);if(r&&(e=cutTree(t,n.tree,s+n.offset,r.pos+n.offset,!1)))return {state:r.state,tree:e}}return {state:t.streamParser.startState(getIndentUnit(n)),tree:Tree.empty}}class Parse{constructor(t,e,s,n){this.lang=t,this.input=e,this.startPos=s,this.context=n,this.chunks=[],this.chunkPos=[],this.chunk=[];let{state:r,tree:i}=findStartInFragments(t,n.fragments,s,n.state);this.state=r,this.pos=this.chunkStart=s+i.length,i.length&&(this.chunks.push(i),this.chunkPos.push(0)),this.pos<n.viewport.from-1e5&&(this.state=this.lang.streamParser.startState(getIndentUnit(n.state)),n.skipUntilInView(this.pos,n.viewport.from),this.pos=n.viewport.from);}advance(){let t=Math.min(this.context.viewport.to,this.input.length,this.chunkStart+2048);for(;this.pos<t;)this.parseLine();return this.chunkStart<this.pos&&this.finishChunk(),t<this.input.length&&this.pos<this.context.viewport.to?null:(this.context.skipUntilInView(this.pos,this.input.length),this.finish())}parseLine(){let t=this.input.lineAfter(this.pos),{streamParser:e}=this.lang,s=new StringStream(t,this.context?this.context.state.tabSize:4,getIndentUnit(this.context.state));if(s.eol())e.blankLine(this.state,s.indentUnit);else for(;!s.eol();){let t=readToken(e.token,s,this.state);t&&this.chunk.push(tokenID(t),this.pos+s.start,this.pos+s.pos,4);}this.pos+=t.length,this.pos<this.input.length&&this.pos++;}finishChunk(){let t=Tree.build({buffer:this.chunk,start:this.chunkStart,length:this.pos-this.chunkStart,nodeSet:nodeSet,topID:0,maxBufferLength:2048});this.lang.stateAfter.set(t,this.lang.streamParser.copyState(this.state)),this.chunks.push(t),this.chunkPos.push(this.chunkStart-this.startPos),this.chunk=[],this.chunkStart=this.pos;}finish(){return new Tree(this.lang.topNode,this.chunks,this.chunkPos,this.pos-this.startPos).balance()}forceFinish(){return this.finish()}}function readToken(t,e,s){e.start=e.pos;for(let n=0;n<10;n++){let n=t(e,s);if(e.pos>e.start)return n}throw new Error("Stream parser failed to advance stream.")}const tokenTable=Object.create(null),typeArray=[NodeType.none],nodeSet=new NodeSet(typeArray),warned=[];function tokenID(t){return t?tokenTable[t]||(tokenTable[t]=createTokenType(t)):0}for(let[t,e]of [["variable","variableName"],["variable-2","variableName.special"],["string-2","string.special"],["def","variableName.definition"],["tag","typeName"],["attribute","propertyName"],["type","typeName"],["builtin","variableName.standard"],["qualifier","modifier"],["error","invalid"],["header","heading"],["property","propertyName"]])tokenTable[t]=tokenID(e);function warnForPart(t,e){warned.indexOf(t)>-1||(warned.push(t),console.warn(e));}function createTokenType(t){let e=null;for(let s of t.split(".")){let t=tags[s];t?"function"==typeof t?e?e=t(e):warnForPart(s,`Modifier ${s} used at start of tag`):e?warnForPart(s,`Tag ${s} used as modifier`):e=t:warnForPart(s,`Unknown highlighting tag ${s}`);}if(!e)return 0;let s=t.replace(/ /g,"_"),n=NodeType.define({id:typeArray.length,name:s,props:[styleTags({[s]:e})]});return typeArray.push(n),n.id}function docID(t){let e=NodeType.define({id:typeArray.length,name:"Document",props:[languageDataProp.add((()=>t))]});return typeArray.push(e),e}

export { StreamLanguage, StringStream };
